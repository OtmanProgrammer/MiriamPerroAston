<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de lanzar y traer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
            cursor: grab; 
        }

        body:active {
            cursor: grabbing;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px 24px;
            border-radius: 30px;
            pointer-events: none;
            color: #333;
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            text-align: center;
            border: 2px solid #D2B48C;
            opacity: 1;
            transition: opacity 0.5s;
        }

        /* Estilos para los botones de selecci√≥n */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            pointer-events: auto; /* Para que los botones funcionen */
        }

        .toy-btn {
            background: #fff;
            border: 2px solid #D2B48C;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 26px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            outline: none;
        }

        .toy-btn:hover {
            transform: scale(1.1);
            background: #FFF8DC;
        }

        .toy-btn.active {
            background: #D2B48C;
            border-color: #8B4513;
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>

    <div id="inst" class="instructions">‚úã Lanza el juguete lejos y el perro te lo traer√°</div>
    
    <!-- Controles para elegir juguete -->
    <div class="controls" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
        <button class="toy-btn active" onclick="setToy('bone')" title="Hueso">ü¶¥</button>
        <button class="toy-btn" onclick="setToy('ball')" title="Pelota">üéæ</button>
        <button class="toy-btn" onclick="setToy('frisbee')" title="Disco">ü•è</button>
        <button class="toy-btn" onclick="setToy('teddy')" title="Peluche">üß∏</button>
        <button class="toy-btn" onclick="setToy('book')" title="Libro">üìñ</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const inst = document.getElementById('inst');

        let width, height;
        let particles = []; 
        let ripples = []; 

        const state = {
            dog: { 
                x: 0, y: 0, 
                size: 1.2, 
                speed: 6, 
                flip: false, 
                yOffset: 0, 
                hopTimer: 0, 
                isMoving: false,
                isSwimming: false,
                wasSwimming: false, 
                sinkFactor: 0, 
                mode: 'IDLE' 
            },
            ball: { x: 0, y: 0, vx: 0, vy: 0, size: 45, rotation: 0 }, 
            mouse: { x: 0, y: 0 }, 
            isDragging: false,
            currentToy: 'ü¶¥', // Emoji para otros juguetes
            toyType: 'bone'   // Tipo de juguete para controlar el dibujo
        };

        // Funci√≥n para cambiar de juguete
        window.setToy = function(type) {
            state.toyType = type; // Guardamos el tipo
            
            const toys = {
                'bone': 'ü¶¥',
                'ball': 'üéæ', // Este emoji ya no se usar√° para dibujar, solo referencia
                'frisbee': 'ü•è',
                'teddy': 'üß∏',
                'book': 'üìñ'
            };
            state.currentToy = toys[type];

            // Actualizar botones visualmente
            const buttons = document.querySelectorAll('.toy-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            buttons.forEach(btn => {
                if(btn.getAttribute('onclick').includes(type)) {
                    btn.classList.add('active');
                }
            });
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        window.addEventListener('resize', resize);
        resize();

        // Posiciones iniciales
        state.dog.x = width / 2;
        state.dog.y = height * 0.7;
        state.ball.x = width / 2 + 50;
        state.ball.y = height * 0.7 + 50;
        state.mouse.x = width / 2;
        state.mouse.y = height * 0.8;

        // --- INTERACCI√ìN ---
        function updateMouse(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            state.mouse.x = clientX;
            state.mouse.y = clientY;

            if (state.isDragging) {
                state.ball.vx = (clientX - state.ball.x) * 0.2;
                state.ball.vy = (clientY - state.ball.y) * 0.2;
                state.ball.x = clientX;
                state.ball.y = clientY;
            }
        }

        const startDrag = (e) => {
            // Evitar drag si tocamos los controles (manejado por stopPropagation en el div, pero doble check)
            if (e.target.closest('.controls')) return;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const dx = clientX - state.ball.x;
            const dy = clientY - state.ball.y;
            
            if (Math.sqrt(dx*dx + dy*dy) < 80) {
                state.isDragging = true;
                state.dog.mode = 'IDLE'; 
            }
            updateMouse(e);
        };

        window.addEventListener('mousedown', startDrag);
        window.addEventListener('touchstart', startDrag, {passive: false});
        
        window.addEventListener('mousemove', updateMouse);
        window.addEventListener('touchmove', (e) => { e.preventDefault(); updateMouse(e); }, {passive: false});

        const endDrag = () => { 
            if (state.isDragging) {
                state.isDragging = false; 
                state.dog.mode = 'CHASING';
                state.ball.vx = Math.max(-25, Math.min(25, state.ball.vx));
                state.ball.vy = Math.max(-25, Math.min(25, state.ball.vy));
            }
        };
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        // --- CLASES ---
        class Ripple {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = 1; this.life = 1.0;
            }
            update() { this.size += 2; this.life -= 0.02; }
            draw(ctx) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size * 2, this.size, 0, 0, Math.PI*2);
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, type = 'emotion') {
                this.x = x; this.y = y; this.type = type; this.life = 1.0;
                if (type === 'water') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = -Math.random() * 5 - 2;
                    this.radius = Math.random() * 3 + 1;
                    this.color = '#E0F7FA';
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = -Math.random() * 4 - 2;
                    // Emociones variadas
                    const toySymbol = state.toyType === 'ball' ? 'üéæ' : state.currentToy;
                    this.text = ['‚ù§Ô∏è', toySymbol, 'Buen chico!'][Math.floor(Math.random() * 3)];
                }
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life -= 0.03;
                if(this.type === 'water') { this.vy += 0.25; this.life -= 0.01; }
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                if (this.type === 'water') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = '#000';
                    ctx.fillText(this.text, this.x, this.y);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        function drawGermanShepherd(ctx, scale, runCycle, isMoving, isSwimming, hasBone, sinkFactor) {
            ctx.save();
            ctx.scale(scale, scale);

            const tanColor = '#C69C6D'; 
            const blackColor = '#2F2F2F';
            const cycleSpeed = isSwimming ? 0.5 : 1;
            const legAmp = isMoving ? 0.8 : 0;
            const legSwing = Math.sin(runCycle * cycleSpeed) * legAmp; 
            const legSwing2 = Math.sin(runCycle * cycleSpeed + Math.PI) * legAmp;

            function drawLeg(x, y, angle, color) {
                ctx.save();
                ctx.translate(x, y);
                const swimRotation = (Math.PI / 4) * sinkFactor; 
                ctx.rotate(angle + swimRotation);
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.ellipse(0, 10, 8, 18, 0, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.translate(0, 25);
                ctx.rotate(isMoving ? -Math.abs(angle)*0.5 : 0); 
                ctx.ellipse(0, 5, 6, 12, 0, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.fillStyle = blackColor;
                ctx.ellipse(3, 15, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            // Cola
            const tailWag = Math.sin(runCycle * 4) * 0.4;
            ctx.save();
            ctx.translate(-35, -5);
            const tailBaseAngle = -0.5 * (1 - sinkFactor) + (-0.2 * sinkFactor);
            ctx.rotate(tailBaseAngle + (isMoving ? tailWag : 0));
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-20, 10, -40, 5); ctx.quadraticCurveTo(-20, -10, 0, -5);
            ctx.fillStyle = blackColor; ctx.fill();
            ctx.restore();

            drawLeg(-25, 5, legSwing2, tanColor);
            drawLeg(25, 5, legSwing, tanColor);

            // Cuerpo
            ctx.save();
            ctx.rotate(-0.1 * sinkFactor);
            ctx.beginPath(); ctx.ellipse(0, -5, 40, 22, 0, 0, Math.PI * 2);
            ctx.fillStyle = tanColor; ctx.fill();
            ctx.beginPath(); ctx.ellipse(0, -12, 30, 15, 0, 0, Math.PI * 2);
            ctx.fillStyle = blackColor; ctx.fill();

            // Cabeza
            ctx.save();
            ctx.translate(35, -20); 
            const headAngle = -0.2 * (1 - sinkFactor) + (-0.5 * sinkFactor);
            ctx.rotate(headAngle); 
            
            ctx.beginPath(); ctx.moveTo(-10, 10); ctx.lineTo(-5, -15); ctx.lineTo(15, -15); ctx.lineTo(15, 10);
            ctx.fillStyle = tanColor; ctx.fill();
            ctx.beginPath(); ctx.arc(5, -15, 18, 0, Math.PI*2); ctx.fillStyle = tanColor; ctx.fill();
            // Orejas
            ctx.beginPath(); ctx.moveTo(-5, -25); ctx.lineTo(-2, -45); ctx.lineTo(10, -28); ctx.fill();
            ctx.beginPath(); ctx.moveTo(5, -28); ctx.lineTo(15, -45); ctx.lineTo(18, -25); ctx.fill();
            ctx.fillStyle = '#444'; 
            ctx.beginPath(); ctx.moveTo(0, -28); ctx.lineTo(-2, -40); ctx.lineTo(5, -30); ctx.fill();
            // Hocico
            ctx.fillStyle = blackColor;
            ctx.beginPath(); ctx.moveTo(15, -15); ctx.lineTo(32, -12); ctx.lineTo(30, -5); ctx.lineTo(15, -5); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(32, -14, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(12, -20, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(13, -20, 1.5, 0, Math.PI*2); ctx.fill();

            // JUGUETE EN LA BOCA
            if (hasBone) {
                ctx.save();
                ctx.translate(25, -8); 
                ctx.rotate(0.2);
                
                // Si es la pelota, la dibujamos manualmente
                if (state.toyType === 'ball') {
                    const r = (state.ball.size / scale) / 2; // Radio ajustado a la escala
                    
                    // Base pelota
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = '#CCFF00'; // Verde Tenis brillante
                    ctx.fill();
                    ctx.strokeStyle = '#99CC00';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // L√≠neas blancas de la pelota
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(r/1.5, 0, r/1.5, Math.PI, 3*Math.PI); // Curva 1
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(-r/1.5, 0, r/1.5, 0, 2*Math.PI); // Curva 2
                    ctx.stroke();

                } else {
                    // Resto de juguetes (Emojis: Hueso, Libro, etc)
                    const adjustedSize = state.ball.size / scale; 
                    ctx.font = `${adjustedSize}px Arial`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(state.currentToy, 0, 0);
                }
                ctx.restore();
            }

            ctx.restore(); 
            ctx.restore(); 
            drawLeg(-25, 5, legSwing, tanColor);
            drawLeg(25, 5, legSwing2, tanColor);
            ctx.restore();
        }

        // --- BUCLE PRINCIPAL ---

        function update() {
            const skyLine = height * 0.3;    
            const sandLine = height * 0.6;  

            // --- F√çSICA JUGUETE ---
            if (!state.isDragging && state.dog.mode !== 'RETURNING') {
                state.ball.x += state.ball.vx;
                state.ball.y += state.ball.vy;
                
                // Rotaci√≥n simple basada en la velocidad X
                state.ball.rotation += state.ball.vx * 0.05;

                if (state.ball.x < state.ball.size || state.ball.x > width - state.ball.size) {
                    state.ball.vx *= -0.7;
                    state.ball.x = Math.max(state.ball.size, Math.min(state.ball.x, width - state.ball.size));
                }
                if (state.ball.y < skyLine + state.ball.size/2) {
                    state.ball.vy *= -0.7;
                    state.ball.y = skyLine + state.ball.size/2;
                } else if (state.ball.y > height - state.ball.size) {
                    state.ball.vy *= -0.7;
                    state.ball.y = height - state.ball.size;
                }
                
                let friction = 0.98;
                if (state.ball.y < sandLine) friction = 0.94; 
                state.ball.vx *= friction;
                state.ball.vy *= friction;

                if (Math.abs(state.ball.vx) < 0.1) state.ball.vx = 0;
                if (Math.abs(state.ball.vy) < 0.1) state.ball.vy = 0;
            }

            // --- IA PERRO ---
            const inWater = state.dog.y < sandLine;
            state.dog.isSwimming = inWater;

            if (inWater) {
                if (state.dog.sinkFactor < 1) state.dog.sinkFactor += 0.05;
            } else {
                if (state.dog.sinkFactor > 0) state.dog.sinkFactor -= 0.05;
            }

            if (inWater && !state.dog.wasSwimming) {
                for(let i=0; i<10; i++) particles.push(new Particle(state.dog.x, state.dog.y + 20, 'water'));
                ripples.push(new Ripple(state.dog.x, state.dog.y + 20));
            }
            state.dog.wasSwimming = inWater;

            if (inWater && state.dog.isMoving && Math.floor(Date.now() / 100) % 5 === 0) {
                 ripples.push(new Ripple(state.dog.x, state.dog.y + 15));
            }

            let targetX = state.dog.x;
            let targetY = state.dog.y;

            if (state.dog.mode === 'CHASING') {
                targetX = state.ball.x;
                targetY = state.ball.y;
                if (Math.hypot(state.ball.x - state.dog.x, state.ball.y - state.dog.y) < 40) {
                    state.dog.mode = 'RETURNING';
                    particles.push(new Particle(state.dog.x, state.dog.y - 30));
                }
            }
            else if (state.dog.mode === 'RETURNING') {
                targetX = state.mouse.x;
                targetY = state.mouse.y;
                state.ball.x = state.dog.x; 
                state.ball.y = state.dog.y; 
                state.ball.rotation = 0; // Reset rotaci√≥n al recoger
                if (Math.hypot(state.mouse.x - state.dog.x, state.mouse.y - state.dog.y) < 60) {
                    state.dog.mode = 'IDLE';
                    state.ball.x = state.dog.x;
                    state.ball.y = state.dog.y + 20; 
                    state.ball.vx = 0;
                    state.ball.vy = 0;
                    particles.push(new Particle(state.dog.x, state.dog.y - 40, 'emotion'));
                }
            }
            else { // IDLE
                const distToMaster = Math.hypot(state.mouse.x - state.dog.x, state.mouse.y - state.dog.y);
                if (distToMaster > 150) {
                      targetX = state.mouse.x;
                      targetY = state.mouse.y;
                } else {
                    targetX = state.dog.x; 
                    targetY = state.dog.y;
                    if (state.isDragging) state.dog.flip = state.ball.x < state.dog.x;
                    else state.dog.flip = state.mouse.x < state.dog.x;
                }
            }

            const dx = targetX - state.dog.x;
            const dy = targetY - state.dog.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 10) {
                state.dog.isMoving = true;
                const angle = Math.atan2(dy, dx);
                let speed = state.dog.speed;
                if (state.dog.mode === 'IDLE') speed *= 0.3; 
                if (inWater) speed *= 0.6;       
                
                state.dog.x += Math.cos(angle) * speed;
                state.dog.y += Math.sin(angle) * speed;

                if (state.dog.y < skyLine + 20) state.dog.y = skyLine + 20;
                if (state.dog.y > height - 20) state.dog.y = height - 20;

                state.dog.hopTimer += 0.2;
                const waterBounce = Math.sin(state.dog.hopTimer) * 2;
                const landBounce = Math.abs(Math.sin(state.dog.hopTimer)) * -10;
                state.dog.yOffset = landBounce * (1 - state.dog.sinkFactor) + waterBounce * state.dog.sinkFactor;
                state.dog.flip = dx < 0;
                if (inWater && Math.random() < 0.2) {
                    particles.push(new Particle(state.dog.x, state.dog.y + 20, 'water'));
                }
            } else {
                state.dog.isMoving = false;
                state.dog.yOffset = 0;
                state.dog.hopTimer = 0;
            }

            particles.forEach((p, i) => {
                p.update();
                if(p.life <= 0) particles.splice(i,1);
            });
            ripples.forEach((r, i) => {
                r.update();
                if(r.life <= 0) ripples.splice(i,1);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            const skyLine = height * 0.3;
            const sandLine = height * 0.6;

            const seaGrad = ctx.createLinearGradient(0, skyLine, 0, sandLine);
            seaGrad.addColorStop(0, '#1E90FF'); seaGrad.addColorStop(1, '#00BFFF'); 
            ctx.fillStyle = seaGrad; ctx.fillRect(0, skyLine, width, sandLine - skyLine);
            
            ctx.beginPath(); ctx.moveTo(0, skyLine); ctx.lineTo(width, skyLine);
            ctx.strokeStyle = '#1874CD'; ctx.lineWidth = 2; ctx.stroke();
            
            const sandGrad = ctx.createLinearGradient(0, sandLine, 0, height);
            sandGrad.addColorStop(0, '#F4A460'); sandGrad.addColorStop(1, '#F0E68C'); 
            ctx.fillStyle = sandGrad; ctx.fillRect(0, sandLine, width, height - sandLine);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            for(let i=0; i<width; i+=20) ctx.arc(i, sandLine, 10, 0, Math.PI*2);
            ctx.fill();
            
            ctx.save();
            ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#FFA500'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(width - 80, 80, 40, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // MENSAJE AMOROSO DEL LIBRO
            if (state.toyType === 'book') {
                ctx.save();
                ctx.font = 'italic bold 30px "Times New Roman", serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Sombra suave
                ctx.fillText('"Mi-e dor de tine"', width/2 + 2, height/2 + 2);
                ctx.fillStyle = '#4B0082'; // Color √çndigo elegante
                ctx.fillText('"Mi-e dor de tine"', width/2, height/2);
                ctx.restore();
            }

            // Sombra perro
            ctx.fillStyle = `rgba(0,0,0,${0.15 * (1 - state.dog.sinkFactor)})`; 
            ctx.beginPath(); ctx.ellipse(state.dog.x, state.dog.y + 35, 40, 10, 0, 0, Math.PI*2); ctx.fill();
            
            ripples.forEach(r => r.draw(ctx));

            // Perro
            ctx.save();
            let sinkY = 15 * state.dog.sinkFactor;
            let drawY = state.dog.y + state.dog.yOffset + sinkY;
            ctx.translate(state.dog.x, drawY);
            if (state.dog.flip) ctx.scale(-1, 1);
            
            const hasBone = state.dog.mode === 'RETURNING';
            drawGermanShepherd(ctx, state.dog.size, state.dog.hopTimer, state.dog.isMoving, state.dog.isSwimming, hasBone, state.dog.sinkFactor);
            ctx.restore();

            // Overlay Agua
            if (state.dog.sinkFactor > 0.05) {
                ctx.save();
                ctx.beginPath(); ctx.rect(0, 0, width, sandLine); ctx.clip();
                ctx.globalAlpha = state.dog.sinkFactor; 
                const waterGrad = ctx.createLinearGradient(0, state.dog.y - 10, 0, state.dog.y + 40);
                waterGrad.addColorStop(0, 'rgba(30, 144, 255, 0.0)');
                waterGrad.addColorStop(0.4, 'rgba(30, 144, 255, 0.3)');
                waterGrad.addColorStop(1, 'rgba(0, 60, 150, 0.6)');    
                ctx.fillStyle = waterGrad;
                ctx.beginPath(); ctx.ellipse(state.dog.x, state.dog.y + 15, 55, 35, 0, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.ellipse(state.dog.x, state.dog.y + 15, 50, 12, 0, 0, Math.PI*2); ctx.stroke();
                ctx.restore(); 
            }

            // --- JUGUETE (SUELTO) ---
            if (state.dog.mode !== 'RETURNING') {
                ctx.save();
                ctx.translate(state.ball.x, state.ball.y);
                // Sombra
                if (state.ball.y < sandLine) {
                      ctx.fillStyle = 'rgba(30, 144, 255, 0.3)';
                      ctx.beginPath(); ctx.ellipse(0, 10, state.ball.size/2 + 5, 10, 0, 0, Math.PI*2); ctx.fill();
                } else {
                      ctx.fillStyle = 'rgba(0,0,0,0.15)';
                      ctx.beginPath(); ctx.ellipse(0, state.ball.size/2 + 5, state.ball.size/2, 10, 0, 0, Math.PI*2); ctx.fill();
                }
                
                // Rotar juguete al lanzarlo
                ctx.rotate(state.ball.rotation);

                // DIBUJAR JUGUETE
                if (state.toyType === 'ball') {
                    // DIBUJO MANUAL DE PELOTA DE TENIS
                    const r = state.ball.size / 2;
                    
                    // C√≠rculo base
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = '#CCFF00'; // Verde Tenis
                    ctx.fill();
                    
                    // Borde sutil
                    ctx.strokeStyle = '#99CC00';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Costuras blancas
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    
                    ctx.beginPath();
                    ctx.arc(r/1.5, 0, r/1.5, 0.5 * Math.PI, 1.5 * Math.PI, true); 
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(-r/1.5, 0, r/1.5, 1.5 * Math.PI, 0.5 * Math.PI, true);
                    ctx.stroke();

                } else {
                    // EMOJIS (Hueso, Frisbee, Peluche, Libro)
                    ctx.fillStyle = 'black'; 
                    ctx.font = `${state.ball.size}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(state.currentToy, 0, 0);
                }
                
                ctx.restore();
            }

            particles.forEach(p => p.draw(ctx));

            requestAnimationFrame(updateAndDraw);
        }

        function updateAndDraw() {
            update();
            draw();
        }

        updateAndDraw();

    </script>
</body>
</html>
